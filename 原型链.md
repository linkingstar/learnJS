# [原型链](https://juejin.cn/post/6844904070579240974#heading-0)

参考以下代码

```js
function person() {
  this.name = 10;
}
person.prototype.age = 10;
const p = new person();
```

## 分析对象类型

运行该代码并进行 debug，先查看 person 的属性  
![](https://user-gold-cdn.xitu.io/2020/2/23/17071456b8ce57da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以得出函数的原型主要包含两个属性：prototype 跟`__proto__`

![](https://user-gold-cdn.xitu.io/2020/2/23/1707146b212791f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

prototype 包含了构造函数，用户在 prototype 上定义的属性，以及`__proto__`属性。  
点开构造函数，可以发现构造函数指向了 function person 的定义（其实就是循环引用，套娃了）
因此`prototype`可以翻译成`原先对象`,用来扩展属性跟方法。

`__proto__`指向了原始的 function 对象，在 function 中，`__proto__`指向了 object 对象，在 object 对象中，`__proto__`指向了 null,如下图所示

![](https://user-gold-cdn.xitu.io/2020/2/23/1707146f25a52c6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因此 person 的原型链，可以描述如下
person -> function -> object -> null

## 分析生成的对象（对象实例）

下图解析了实例`p`的原型

![](https://user-gold-cdn.xitu.io/2020/2/23/1707147517b6abe2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

p 的`__proto__`实际上指向了 person 的 prototype，这一步其实也是 new 的核心。
那么类型跟实例之间的关系可以总结为下图

![](https://user-gold-cdn.xitu.io/2020/2/23/1707147d8d6854bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

那么对于实例 p，原型链为

p.`__proto__` => {constructor:func}.`__proto__` => Object => null

对于实例对象来说，原型链的意义是

- 实现继承
- 沿着原型链查找某个属性是否存在
- 判断实例是否为某个类型(instance of,type of 之类的判断)

# 关于构造函数

首先构造函数跟普通函数没有特别大区别，除了构造函数需要通过`new`来调用

> 注意：箭头函数不能作为构造函数

构造函数的原理如下：

- 创建一个空对象{}，分配存储空间
- 从参数列表中获取参数，要求第一个函数必须为构造函数
- 将 obj 的`__proto__`指向构造函数的 prototype(原型)
- 通过 apply 执行构造，并将当前 this 的指向改为 obj
- 返回构造函数的执行结果，或者当前的 obj 对象

```js
function objectFactory() {
  var obj = {},
    Constructor = [].shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  var ret = Constructor.apply(obj, arguments);
  return typeof ret === 'object' ? ret : obj;
}
function fnf() {
  this.x = 123;
}
let a2 = objectFactory(fnf); // 模拟 new fnf()
console.log(a2.x); // 123
```
