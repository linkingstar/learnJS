# [原型链](https://juejin.cn/post/6844904070579240974#heading-0)

# 总结

JavaScript 常被描述为一种**基于原型的语言 (prototype-based language)**——每个对象拥有一个**原型对象**，对象以其原型为模板、从原型继承方法和属性。原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为**原型链 (prototype chain)**，它解释了为何一个对象会拥有定义在其他对象中的属性和方法。

准确地说，这些属性和方法定义在Object的构造器函数(constructor functions)之上的`prototype`属性上，而非对象实例本身。

在传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。在 JavaScript 中并不如此复制——而是在**对象实例和它的构造器之间建立一个链接**（它是__proto__属性，是从构造函数的`prototype`属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法。

> **注意:** 理解对象的原型（可以通过`Object.getPrototypeOf(obj)`或者已被弃用的`__proto__`属性获得）与构造函数的`prototype`属性之间的区别是很重要的。前者是每个实例上都有的属性，后者是构造函数的属性。也就是说，**`Object.getPrototypeOf(new Foobar())`和`Foobar.prototype`指向着同一个对象。**

举例说明：

```js
function doSomething(){}
console.log( doSomething.prototype );

const f1 = new doSomething();
// 实例的 `__proto__`实际上是指向了 对象的prototype
f1.__proto__ === doSomething.prototype //true

doSomething.bar = 'bar';
// 通过f1的原型链找到`bar`
console.log(f1.bar)
// 通过f1的原型链往上找到object的原型链中的 `valueOf`函数
console.log(f1.valueOf())
```



参考以下代码

```js
function person() {
  this.name = 10;
}
person.prototype.age = 10;
const p = new person();
```

## 分析对象类型

运行该代码并进行 debug，先查看 person 的属性  
![](https://user-gold-cdn.xitu.io/2020/2/23/17071456b8ce57da?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以得出函数的原型主要包含两个属性：prototype 跟`__proto__`

![](https://user-gold-cdn.xitu.io/2020/2/23/1707146b212791f2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

prototype 包含了构造函数，用户在 prototype 上定义的属性，以及`__proto__`属性。  
点开构造函数，可以发现构造函数指向了 function person 的定义（其实就是循环引用，套娃了）
因此`prototype`可以翻译成`原先对象`,用来扩展属性跟方法。

`__proto__`指向了原始的 function 对象，在 function 中，`__proto__`指向了 object 对象，在 object 对象中，`__proto__`指向了 null,如下图所示

![](https://user-gold-cdn.xitu.io/2020/2/23/1707146f25a52c6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因此 person 的原型链，可以描述如下
person -> function -> object -> null

## 分析生成的对象（对象实例）

下图解析了实例`p`的原型

![](https://user-gold-cdn.xitu.io/2020/2/23/1707147517b6abe2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

p 的`__proto__`实际上指向了 person 的 prototype，这一步其实也是 new 的核心。
那么类型跟实例之间的关系可以总结为下图

![](https://user-gold-cdn.xitu.io/2020/2/23/1707147d8d6854bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

那么对于实例 p，原型链为

p.`__proto__` => {constructor:func}.`__proto__` => Object => null

对于实例对象来说，原型链的意义是

- 实现继承
- 沿着原型链查找某个属性是否存在
- 判断实例是否为某个类型(instance of,type of 之类的判断)

# 关于构造函数

首先构造函数跟普通函数没有特别大区别，除了构造函数需要通过`new`来调用

> 注意：箭头函数不能作为构造函数

构造函数的原理如下：

- 创建一个空对象{}，分配存储空间
- 从参数列表中获取参数，要求第一个函数必须为构造函数
- 将 obj 的`__proto__`指向构造函数的 prototype(原型)
- 通过 apply 执行构造，并将当前 this 的指向改为 obj
- 返回构造函数的执行结果，或者当前的 obj 对象

```js
function objectFactory() {
  var obj = {},
    Constructor = [].shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  var ret = Constructor.apply(obj, arguments);
  return typeof ret === 'object' ? ret : obj;
}
function fnf() {
  this.x = 123;
}
let a2 = objectFactory(fnf); // 模拟 new fnf()
console.log(a2.x); // 123
```
